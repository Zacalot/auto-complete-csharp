;;; auto-complete-csharp.el --- Auto-completion source for C# keywords to be used with the auto-complete package

;; Author: Zacalot
;; Url: https://github.com/Zacalot/auto-complete-csharp
;; Version: 1.0.0
;; Package-Requires: ((emacs "24.1"))
;; Keywords: C#, csharp, auto-complete

;;; Commentary:

;; This package is to be used with the `auto-complete' package.
;; C# functions are not included because you should use a LSP server for those.
;; This package is useful when C# LSP servers are too slow for delay-activated autocomplete.
;; Documentation for keywords are adapted from https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/

;;; Usage:

;; Add `ac-source-csharp' to your `ac-sources' variable while in `csharp-mode'
;; Example code:
;; (require 'auto-complete-csharp)
;; (add-hook 'csharp-mode-hook #'(lambda ()
;;                                 (setq ac-sources '(ac-source-csharp))
;;                                 (auto-complete-mode)))

;;; Code:

(defvar auto-complete-csharp--keywords
  '(
    ("abstract" . "The abstract modifier indicates that the thing being modified has a missing or incomplete implementation. The abstract modifier can be used with classes, methods, properties, indexers, and events. Use the abstract modifier in a class declaration to indicate that a class is intended only to be a base class of other classes, not instantiated on its own. Members marked as abstract must be implemented by non-abstract classes that derive from the abstract class.")
    ("as" . "The as operator explicitly converts the result of an expression to a given reference or nullable value type. If the conversion isn't possible, the as operator returns null. Unlike a cast expression, the as operator never throws an exception.")
    ("base" . "The base keyword is used to access members of the base class from within a derived class.")
    ("bool" . "The bool type keyword is an alias for the .NET System.Boolean structure type that represents a Boolean value, which can be either true or false.")
    ("break" . "The break statement terminates the closest enclosing iteration statement (that is, for, foreach, while, or do loop) or switch statement. The break statement transfers control to the statement that follows the terminated statement, if any.")
    ("byte" . "Unsigned 8-bit integer, range 0 to 255")
    ("case" . "The switch statement selects a statement list to execute based on a pattern match with a match expression.")
    ("catch" . "Use the try-catch statement to handle exceptions that might occur during execution of a code block. Place the code where an exception might occur inside a try block.")
    ("char" . "The char type keyword is an alias for the .NET System.Char structure type that represents a Unicode UTF-16 character.")
    ("checked" . "The checked and unchecked statements specify the overflow-checking context for integral-type arithmetic operations and conversions. When integer arithmetic overflow occurs, the overflow-checking context defines what happens. In a checked context, a System.OverflowException is thrown; if overflow happens in a constant expression, a compile-time error occurs. In an unchecked context, the operation result is truncated by discarding any high-order bits that don't fit in the destination type. For example, in the case of addition it wraps from the maximum value to the minimum value")
    ("class" . "Classes are declared using the keyword class.")
    ("const" . "You use the const keyword to declare a constant field or a local constant. Constant fields and locals aren't variables and may not be modified. Constants can be numbers, Boolean values, strings, or a null reference. Don’t create a constant to represent information that you expect to change at any time. For example, don’t use a constant field to store the price of a service, a product version number, or the brand name of a company. These values can change over time, and because compilers propagate constants, other code compiled with your libraries will have to be recompiled to see the changes. See also the readonly keyword.")
    ("continue" . "The continue statement starts a new iteration of the closest enclosing iteration statement (that is, for, foreach, while, or do loop).")
    ("decimal" . "Floating-point numeric type representing a real number. Size: 16 bytes, Precision: ~28-29 digits, Approximate Range: ±1.0 x 10^-28 to ±7.9228 x 10^28")
    ("default" . "You can use the default keyword in the following contexts: 1. To specify the default case in the switch statement. 2. As the default operator or literal to produce the default value of a type. 3. As the default type constraint on a generic method override or explicit interface implementation.")
    ("delegate" . "The declaration of a delegate type is similar to a method signature. It has a return value and any number of parameters of any type. In .NET, System.Action and System.Func types provide generic definitions for many common delegates. You likely don't need to define new custom delegate types. Instead, you can create instantiations of the provided generic types. A delegate is a reference type that can be used to encapsulate a named or an anonymous method. Delegates are similar to function pointers in C++; however, delegates are type-safe and secure. For applications of delegates, see Delegates and Generic Delegates. Delegates are the basis for Events. A delegate can be instantiated by associating it either with a named or anonymous method. The delegate must be instantiated with a method or lambda expression that has a compatible return type and input parameters. For more information on the degree of variance that is allowed in the method signature, see Variance in Delegates. For use with anonymous methods, the delegate and the code to be associated with it are declared together.")
    ("do" . "The do statement executes a statement or a block of statements while a specified Boolean expression evaluates to true. Because that expression is evaluated after each execution of the loop, a do loop executes one or more times. The do loop differs from the while loop, which executes zero or more times.")
    ("double" . "Floating-point numeric type representing a real number. Size: 8 bytes, Precision: ~15-17 digits, Approximate Range: ±5.0 × 10^−324 to ±1.7 × 10^308")
    ("else" . "The if, if-else and switch statements select statements to execute from many possible paths based on the value of an expression. The if statement executes a statement only if a provided Boolean expression evaluates to true. The if-else statement allows you to choose which of the two code paths to follow based on a Boolean expression. The switch statement selects a statement list to execute based on a pattern match with an expression.")
    ("enum" . "An enumeration type (or enum type) is a value type defined by a set of named constants of the underlying integral numeric type. To define an enumeration type, use the enum keyword and specify the names of enum members. By default, the associated constant values of enum members are of type int; they start with zero and increase by one following the definition text order. You can explicitly specify any other integral numeric type as an underlying type of an enumeration type.")
    ("event" . "The event keyword is used to declare an event in a publisher class.")
    ("explicit" . "Use the operator and implicit or explicit keywords to define an implicit or explicit conversion, respectively. The type that defines a conversion must be either a source type or a target type of that conversion. A conversion between two user-defined types can be defined in either of the two types.")
    ("extern" . "The extern modifier is used to declare a method that is implemented externally. A common use of the extern modifier is with the DllImport attribute when you are using Interop services to call into unmanaged code. In this case, the method must also be declared as static. The extern keyword can also define an external assembly alias, which makes it possible to reference different versions of the same component from within a single assembly. It is an error to use the abstract and extern modifiers together to modify the same member. Using the extern modifier means that the method is implemented outside the C# code, whereas using the abstract modifier means that the method implementation is not provided in the class.")
    ("false" . "The bool type keyword is an alias for the .NET System.Boolean structure type that represents a Boolean value, which can be either true or false.")
    ("finally" . "In a try-finally statement, the finally block is executed when control leaves the try block. Control might leave the try block as a result of normal execution, execution of a jump statement (that is, return, break, continue, or goto), or propagation of an exception out of the try block.")
    ("fixed" . "The fixed statement prevents the garbage collector from relocating a moveable variable and declares a pointer to that variable. The address of a fixed, or pinned, variable doesn't change during execution of the statement. You can use the declared pointer only inside the corresponding fixed statement. The declared pointer is readonly and can't be modified.")
    ("float" . "Floating-point numeric type representing a real number. Size: 4 bytes, Precision: ~6-9 digits, Approximate Range: ±1.5 x 10^−45 to ±3.4 x 10^38")
    ("for" . "The for statement executes a statement or a block of statements while a specified Boolean expression evaluates to true.")
    ("foreach" . "The foreach statement executes a statement or a block of statements for each element in an instance of the type that implements the System.Collections.IEnumerable or System.Collections.Generic.IEnumerable<T> interface.")
    ("goto" . "The goto statement transfers control to a statement that is marked by a label.")
    ("if" . "The if, if-else and switch statements select statements to execute from many possible paths based on the value of an expression. The if statement executes a statement only if a provided Boolean expression evaluates to true. The if-else statement allows you to choose which of the two code paths to follow based on a Boolean expression. The switch statement selects a statement list to execute based on a pattern match with an expression.")
    ("implicit" . "Use the operator and implicit or explicit keywords to define an implicit or explicit conversion, respectively. The type that defines a conversion must be either a source type or a target type of that conversion. A conversion between two user-defined types can be defined in either of the two types.")
    ("in" . "The in keyword is used in the following contexts: 1. generic type parameters in generic interfaces and delegates. 2. As a parameter modifier, which lets you pass an argument to a method by reference rather than by value. 3. foreach statements. 4. from clauses in LINQ query expressions. 5. join clauses in LINQ query expressions.")
    ("int" . "Signed 32-bit integer, range -2,147,483,648 to 2,147,483,647")
    ("interface" . "An interface defines a contract. Any class or struct that implements that contract must provide an implementation of the members defined in the interface. An interface may define a default implementation for members. It may also define static members in order to provide a single implementation for common functionality. Beginning with C# 11, an interface may define static abstract or static virtual members to declare that an implementing type must provide the declared members. Typically, static virtual methods declare that an implementation must define a set of overloaded operators.")
    ("internal" . "The internal keyword is an access modifier for types and type members. Internal types or members are accessible only within files in the same assembly.")
    ("is" . "The is operator checks if the result of an expression is compatible with a given type. For information about the type-testing is operator, see the is operator section of the Type-testing and cast operators article. You can also use the is operator to match an expression against a pattern.")
    ("lock" . "The lock statement acquires the mutual-exclusion lock for a given object, executes a statement block, and then releases the lock. While a lock is held, the thread that holds the lock can again acquire and release the lock. Any other thread is blocked from acquiring the lock and waits until the lock is released. The lock statement ensures that at maximum only one thread executes its body at any time moment.")
    ("long" . "Signed 64-bit integer, range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807")
    ("namespace" . "The namespace keyword is used to declare a scope that contains a set of related objects. You can use a namespace to organize code elements and to create globally unique types.")
    ("new" . "The new operator creates a new instance of a type. You can also use the new keyword as a member declaration modifier or a generic type constraint.")
    ("null" . "The null keyword is a literal that represents a null reference, one that does not refer to any object. null is the default value of reference-type variables. Ordinary value types cannot be null, except for nullable value types.")
    ("object" . "The object type is an alias for System.Object in .NET. In the unified type system of C#, all types, predefined and user-defined, reference types and value types, inherit directly or indirectly from System.Object. You can assign values of any type to variables of type object. Any object variable can be assigned to its default value using the literal null. When a variable of a value type is converted to object, it's said to be boxed. When a variable of type object is converted to a value type, it's said to be unboxed. For more information, see Boxing and Unboxing.")
    ("operator" . "Use the operator and implicit or explicit keywords to define an implicit or explicit conversion, respectively. The type that defines a conversion must be either a source type or a target type of that conversion. A conversion between two user-defined types can be defined in either of the two types.")
    ("out" . "You can use the out keyword in two contexts: 1. As a parameter modifier, which lets you pass an argument to a method by reference rather than by value. 2. In generic type parameter declarations for interfaces and delegates, which specifies that a type parameter is covariant.")
    ("override" . "The override modifier is required to extend or modify the abstract or virtual implementation of an inherited method, property, indexer, or event.")
    ("params" . "No other parameters are permitted after the params keyword in a method declaration, and only one params keyword is permitted in a method declaration. If the declared type of the params parameter isn't a single-dimensional array, compiler error CS0225 occurs. When you call a method with a params parameter, you can pass in: 1. A comma-separated list of arguments of the type of the array elements. 2. An array of arguments of the specified type. 3. No arguments. If you send no arguments, the length of the params list is zero.")
    ("private" . "The private keyword is a member access modifier. Private access is the least permissive access level. Private members are accessible only within the body of the class or the struct in which they are declared.")
    ("protected" . "The protected keyword is a member access modifier. A protected member is accessible within its class and by derived class instances.")
    ("public" . "The public keyword is an access modifier for types and type members. Public access is the most permissive access level. There are no restrictions on accessing public members.")
    ("readonly" . "The readonly keyword is a modifier that can be used in five contexts: 1. In a field declaration, readonly indicates that assignment to the field can only occur as part of the declaration or in a constructor in the same class. A readonly field can be assigned and reassigned multiple times within the field declaration and constructor. A readonly field can't be assigned after the constructor exits. This rule has different implications for value types and reference types: 1. Because value types directly contain their data, a field that is a readonly value type is immutable. 2. Because reference types contain a reference to their data, a field that is a readonly reference type must always refer to the same object. That object isn't immutable. The readonly modifier prevents the field from being replaced by a different instance of the reference type. However, the modifier doesn't prevent the instance data of the field from being modified through the read-only field. 2. In a readonly struct type definition, readonly indicates that the structure type is immutable. For more information, see the readonly struct section of the Structure types article. 3. In an instance member declaration within a structure type, readonly indicates that an instance member doesn't modify the state of the structure. For more information, see the readonly instance members section of the Structure types article. 4. In a ref readonly method return, the readonly modifier indicates that method returns a reference and writes aren't allowed to that reference.")
    ("ref" . "You use the ref keyword in the following contexts: 1. In a method signature and in a method call, to pass an argument to a method by reference. 2. In a method signature, to return a value to the caller by reference. For more information, see ref return. 3. In a declaration of a local variable, to declare a reference variable section of the Declaration statements article. 4. As the part of a conditional ref expression or a ref assignment operator. 5. In a struct declaration, to declare a ref struct. For more information, see the ref structure types article. 6. In a ref struct definition, to declare a ref field. For more information, see the ref fields section of the ref structure types article.")
    ("return" . "The return statement terminates execution of the function in which it appears and returns control and the function's result, if any, to the caller.")
    ("sbyte" . "Signed 8-bit integer, range -128 to 127")
    ("sealed" . "When applied to a class, the sealed modifier prevents other classes from inheriting from it.")
    ("short" . "Signed 16-bit integer, range -32,768 to 32,767")
    ("sizeof" . "The sizeof operator returns the number of bytes occupied by a variable of a given type. The argument to the sizeof operator must be the name of an unmanaged type or a type parameter that is constrained to be an unmanaged type. The sizeof operator requires an unsafe context. However, the expressions presented in the following table are evaluated in compile time to the corresponding constant values and don't require an unsafe context.")
    ("stackalloc" . "A stackalloc expression allocates a block of memory on the stack. A stack allocated memory block created during the method execution is automatically discarded when that method returns. You can't explicitly free the memory allocated with stackalloc. A stack allocated memory block isn't subject to garbage collection and doesn't have to be pinned with a fixed statement.")
    ("static" . "Use the static modifier to declare a static member, which belongs to the type itself rather than to a specific object. The static modifier can be used to declare static classes. In classes, interfaces, and structs, you may add the static modifier to fields, methods, properties, operators, events, and constructors. The static modifier can't be used with indexers or finalizers. For more information, see Static Classes and Static Class Members. You can add the static modifier to a local function. A static local function can't capture local variables or instance state. Beginning with C# 9.0, you can add the static modifier to a lambda expression or anonymous method. A static lambda or anonymous method can't capture local variables or instance state.")
    ("string" . "The string type represents a sequence of zero or more Unicode characters. string is an alias for System.String in .NET. Although string is a reference type, the equality operators == and != are defined to compare the values of string objects, not references.")
    ("struct" . "A structure type (or struct type) is a value type that can encapsulate data and related functionality. You use the struct keyword to define a structure type.")
    ("switch" . "You use the switch expression to evaluate a single expression from a list of candidate expressions based on a pattern match with an input expression.")
    ("this" . "The this keyword refers to the current instance of the class and is also used as a modifier of the first parameter of an extension method.")
    ("throw" . "The throw statement throws an exception.")
    ("true" . "The bool type keyword is an alias for the .NET System.Boolean structure type that represents a Boolean value, which can be either true or false.")
    ("try" . "You can use the try statement in any of the following forms: try-catch - to handle exceptions that might occur during execution of the code inside a try block, try-finally - to specify the code that is executed when control leaves the try block, and try-catch-finally - as a combination of the preceding two forms.")
    ("typeof" . "The typeof operator obtains the System.Type instance for a type. The argument to the typeof operator must be the name of a type or a type parameter.")
    ("uint" . "Unsigned 32-bit integer, range 0 to 4,294,967,295")
    ("ulong". "Unsigned 64-bit integer, range 0 to 18,446,744,073,709,551,615")
    ("unchecked" . "The checked and unchecked statements specify the overflow-checking context for integral-type arithmetic operations and conversions. When integer arithmetic overflow occurs, the overflow-checking context defines what happens. In a checked context, a System.OverflowException is thrown; if overflow happens in a constant expression, a compile-time error occurs. In an unchecked context, the operation result is truncated by discarding any high-order bits that don't fit in the destination type. For example, in the case of addition it wraps from the maximum value to the minimum value.")
    ("unsafe" . "The unsafe keyword denotes an unsafe context, which is required for any operation involving pointers. For more information, see Unsafe Code and Pointers. You can use the unsafe modifier in the declaration of a type or a member. The entire textual extent of the type or member is therefore considered an unsafe context.")
    ("ushort" . "Unsigned 16-bit integer, range 0 to 65,535")
    ("using" . "The using keyword has two major uses: 1. The using statement defines a scope at the end of which an object is disposed. 2. The using directive creates an alias for a namespace or imports types defined in other namespaces.")
    ("virtual" . "The virtual keyword is used to modify a method, property, indexer, or event declaration and allow for it to be overridden in a derived class. For example, this method can be overridden by any class that inherits it.")
    ("void" . "You use void as the return type of a method (or a local function) to specify that the method doesn't return a value. You can also use void as a referent type to declare a pointer to an unknown type.")
    ("volatile" . "The volatile keyword indicates that a field might be modified by multiple threads that are executing at the same time. The compiler, the runtime system, and even hardware may rearrange reads and writes to memory locations for performance reasons. Fields that are declared volatile are excluded from certain kinds of optimizations. There is no guarantee of a single total ordering of volatile writes as seen from all threads of execution. For more information, see the Volatile class. The volatile keyword can be applied to fields of these types: Reference types. Pointer types (in an unsafe context). Note that although the pointer itself can be volatile, the object that it points to cannot. In other words, you cannot declare a 'pointer to volatile.' Simple types such as sbyte, byte, short, ushort, int, uint, char, float, and bool. An enum type with one of the following base types: byte, sbyte, short, ushort, int, or uint. Generic type parameters known to be reference types. IntPtr and UIntPtr.")
    ("while" . "The while statement executes a statement or a block of statements while a specified Boolean expression evaluates to true. Because that expression is evaluated before each execution of the loop, a while loop executes zero or more times. The while loop differs from the do loop, which executes one or more times.")
    ("add" . "The add contextual keyword is used to define a custom event accessor that is invoked when client code subscribes to your event. If you supply a custom add accessor, you must also supply a remove accessor.")
    ("and" . "Beginning with C# 9.0, you use the not, and, and or pattern combinators to create logical patterns. Conjunctive and pattern that matches an expression when both patterns match the expression.")
    ("alias" . "You might have to reference two versions of assemblies that have the same fully-qualified type names. For example, you might have to use two or more versions of an assembly in the same application. By using an external assembly alias, the namespaces from each assembly can be wrapped inside root-level namespaces named by the alias, which enables them to be used in the same file.")
    ("ascending" . "The ascending contextual keyword is used in the orderby clause in query expressions to specify that the sort order is from smallest to largest. Because ascending is the default sort order, you do not have to specify it.")
    ("args" . "Top-level statements can reference the args variable to access any command-line arguments that were entered. The args variable is never null but its Length is zero if no command-line arguments were provided.")
    ("async" . "Use the async modifier to specify that a method, lambda expression, or anonymous method is asynchronous. If you use this modifier on a method or expression, it's referred to as an async method.")
    ("await" . "The await operator suspends evaluation of the enclosing async method until the asynchronous operation represented by its operand completes. When the asynchronous operation completes, the await operator returns the result of the operation, if any. When the await operator is applied to the operand that represents an already completed operation, it returns the result of the operation immediately without suspension of the enclosing method. The await operator doesn't block the thread that evaluates the async method. When the await operator suspends the enclosing async method, the control returns to the caller of the method.")
    ("by" . "The by contextual keyword is used in the group clause in a query expression to specify how the returned items should be grouped. For more information, see group clause.")
    ("descending" . "The descending contextual keyword is used in the orderby clause in query expressions to specify that the sort order is from largest to smallest.")
    ("dynamic" . "The dynamic type indicates that use of the variable and references to its members bypass compile-time type checking. Instead, these operations are resolved at run time. The dynamic type simplifies access to COM APIs such as the Office Automation APIs, to dynamic APIs such as IronPython libraries, and to the HTML Document Object Model (DOM). Type dynamic behaves like type object in most circumstances. In particular, any non-null expression can be converted to the dynamic type. The dynamic type differs from object in that operations that contain expressions of type dynamic aren't resolved or type checked by the compiler. The compiler packages together information about the operation, and that information is later used to evaluate the operation at run time. As part of the process, variables of type dynamic are compiled into variables of type object. Therefore, type dynamic exists only at compile time, not at run time.")
    ("equals" . "The equals contextual keyword is used in a join clause in a query expression to compare the elements of two sequences. For more information, see join clause.")
    ("file" . "Beginning with C# 11, the file contextual keyword is a type modifier. The file modifier restricts a top-level type's scope and visibility to the file in which it's declared. The file modifier will generally be applied to types written by a source generator. File-local types provide source generators with a convenient way to avoid name collisions among generated types. The file modifier declares a file-local type.")
    ("from" . "A query expression must begin with a from clause. Additionally, a query expression can contain sub-queries, which also begin with a from clause. The from clause specifies the following: The data source on which the query or sub-query will be run. A local range variable that represents each element in the source sequence. Both the range variable and the data source are strongly typed. The data source referenced in the from clause must have a type of IEnumerable, IEnumerable<T>, or a derived type such as IQueryable<T>.")
    ("get" . "The get keyword defines an accessor method in a property or indexer that returns the property value or the indexer element. For more information, see Properties, Auto-Implemented Properties and Indexers.")
    ("global" . "Use the namespace alias qualifier :: to access a member of an aliased namespace. You can use the :: qualifier only between two identifiers. The left-hand identifier can be one of a namespace alias, an extern alias, or the global alias. For example: 1. A namespace alias created with a using alias directive. 2. An extern alias. 3. The global alias, which is the global namespace alias. The global namespace is the namespace that contains namespaces and types that aren't declared inside a named namespace. When used with the :: qualifier, the global alias always references the global namespace, even if there's the user-defined global namespace alias.")
    ("group" . "The group clause returns a sequence of IGrouping<TKey,TElement> objects that contain zero or more items that match the key value for the group. For example, you can group a sequence of strings according to the first letter in each string. In this case, the first letter is the key and has a type char, and is stored in the Key property of each IGrouping<TKey,TElement> object. The compiler infers the type of the key.")
    ("init" . "In C# 9 and later, the init keyword defines an accessor method in a property or indexer. An init-only setter assigns a value to the property or the indexer element only during object construction. This enforces immutability, so that once the object is initialized, it can't be changed again.")
    ("into" . "The into contextual keyword can be used to create a temporary identifier to store the results of a group, join or select clause into a new identifier. This identifier can itself be a generator for additional query commands. When used in a group or select clause, the use of the new identifier is sometimes referred to as a continuation.")
    ("join" . "The join clause is useful for associating elements from different source sequences that have no direct relationship in the object model. The only requirement is that the elements in each source share some value that can be compared for equality. For example, a food distributor might have a list of suppliers of a certain product, and a list of buyers. A join clause can be used, for example, to create a list of the suppliers and buyers of that product who are all in the same specified region. A join clause takes two source sequences as input. The elements in each sequence must either be or contain a property that can be compared to a corresponding property in the other sequence. The join clause compares the specified keys for equality by using the special equals keyword. All joins performed by the join clause are equijoins. The shape of the output of a join clause depends on the specific type of join you are performing. The following are three most common join types: Inner join, Group join, Left outer join")
    ("let" . "In a query expression, it's sometimes useful to store the result of a subexpression in order to use it in subsequent clauses. You can do this with the let keyword, which creates a new range variable and initializes it with the result of the expression you supply. Once initialized with a value, the range variable can't be used to store another value. However, if the range variable holds a queryable type, it can be queried.")
    ("managed" . "You can specify the calling convention for a delegate* using the keywords managed and unmanaged. In addition, for unmanaged function pointers, you can specify the calling convention. The following declarations show examples of each. The first declaration uses the managed calling convention, which is the default. The next four use an unmanaged calling convention. Each specifies one of the ECMA 335 calling conventions: Cdecl, Stdcall, Fastcall, or Thiscall. The last declaration uses the unmanaged calling convention, instructing the CLR to pick the default calling convention for the platform. The CLR will choose the calling convention at run time.")
    ("nameof" . "A nameof expression produces the name of a variable, type, or member as the string constant. A nameof expression is evaluated at compile time and has no effect at run time. When the operand is a type or a namespace, the produced name isn't fully qualified.")
    ("nint" . "Signed 32-bit or 64-bit integer, range depends on platform (computed at runtime)")
    ("not" . "Beginning with C# 9.0, you use the not, and, and or pattern combinators to create logical patterns. Negation not pattern that matches an expression when the negated pattern doesn't match the expression.")
    ("notnull" . "You can use the notnull constraint to specify that the type argument must be a non-nullable value type or non-nullable reference type. Unlike most other constraints, if a type argument violates the notnull constraint, the compiler generates a warning instead of an error. The notnull constraint has an effect only when used in a nullable context. If you add the notnull constraint in a nullable oblivious context, the compiler doesn't generate any warnings or errors for violations of the constraint.")
    ("nuint" . "Unsigned 32-bit or 64-bit integer, range depends on platform (computed at runtime)")
    ("on" . "The on contextual keyword is used in the join clause of a query expression to specify the join condition.")
    ("or". "Beginning with C# 9.0, you use the not, and, and or pattern combinators to create logical patterns. Disjunctive or pattern that matches an expression when either pattern matches the expression.")
    ("orderby" . "In a query expression, the orderby clause causes the returned sequence or subsequence (group) to be sorted in either ascending or descending order. Multiple keys can be specified in order to perform one or more secondary sort operations. The sorting is performed by the default comparer for the type of the element. The default sort order is ascending. You can also specify a custom comparer. However, it is only available by using method-based syntax.")
    ("partial" . "Partial type definitions allow for the definition of a class, struct, interface, or record to be split into multiple files. A partial method has its signature defined in one part of a partial type, and its implementation defined in another part of the type. Partial methods enable class designers to provide method hooks, similar to event handlers, that developers may decide to implement or not. If the developer does not supply an implementation, the compiler removes the signature at compile time. The following conditions apply to partial methods: Declarations must begin with the contextual keyword partial. Signatures in both parts of the partial type must match. The partial keyword isn't allowed on constructors, finalizers, overloaded operators, property declarations, or event declarations. A partial method isn't required to have an implementation in the following cases: It doesn't have any accessibility modifiers (including the default private). It returns void. It doesn't have any out parameters. It doesn't have any of the following modifiers virtual, override, sealed, new, or extern. Any method that doesn't conform to all those restrictions (for example, public virtual partial void method), must provide an implementation.")
    ("record" . "A record in C# is a class or struct that provides special syntax and behavior for working with data models. The record modifier instructs the compiler to synthesize members that are useful for types whose primary role is storing data. These members include an overload of ToString() and members that support value equality.")
    ("remove" . "The remove contextual keyword is used to define a custom event accessor that is invoked when client code unsubscribes from your event. If you supply a custom remove accessor, you must also supply an add accessor.")
    ("required" . "The required modifier indicates that the field or property it's applied to must be initialized by an object initializer. Any expression that initializes a new instance of the type must initialize all required members. The required modifier is available beginning with C# 11. The required modifier enables developers to create types where properties or fields must be properly initialized, yet still allow initialization using object initializers. Several rules ensure this behavior: 1. The required modifier can be applied to fields and properties declared in struct, and class types, including record and record struct types. The required modifier can't be applied to members of an interface. 2. Explicit interface implementations can't be marked as required. They can't be set in object initializers. 3. Required members must be initialized, but they may be initialized to null. If the type is a non-nullable reference type, the compiler issues a warning if you initialize the member to null. The compiler issues an error if the member isn't initialized at all. 4. Required members must be at least as visible as their containing type. For example, a public class can't contain a required field that's protected. Furthermore, required properties must have setters (set or init accessors) that are at least as visible as their containing types. Members that aren't accessible can't be set by code that creates an instance. 5. Derived classes can't hide a required member declared in the base class. Hiding a required member prevents callers from using object initializers for it. Furthermore, derived types that override a required property must include the required modifier. The derived type can't remove the required state. Derived types can add the required modifier when overriding a property. 6. A type with any required members may not be used as a type argument when the type parameter includes the new() constraint. The compiler can't enforce that all required members are initialized in the generic code. 7. The required modifier isn't allowed on the declaration for positional parameters on a record. You can add an explicit declaration for a positional property that does include the required modifier. Some types, such as positional records, use a primary constructor to initialize positional properties. If any of those properties include the required modifier, the primary constructor adds the SetsRequiredMembers attribute. This indicates that the primary constructor initializes all required members. You can write your own constructor with the System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute attribute. However, the compiler doesn't verify that these constructors do initialize all required members. Rather, the attribute asserts to the compiler that the constructor does initialize all required members. The SetsRequiredMembers attribute adds these rules to constructors: A constructor that chains to another constructor annotated with the SetsRequiredMembers attribute, either this(), or base(), must also include the SetsRequiredMembers attribute. That ensures that callers can correctly use all appropriate constructors. Copy constructors generated for record types have the SetsRequiredMembers attribute applied if any of the members are required.
")
    ("scoped" . "The contextual keyword scoped restricts the lifetime of a value. The scoped modifier restricts the ref-safe-to-escape or safe-to-escape lifetime, respectively, to the current method. Effectively, adding the scoped modifier asserts that your code won't extend the lifetime of the variable. You can apply scoped to a parameter or local variable. The scoped modifier may be applied to parameters and locals when the type is a ref struct. Otherwise, the scoped modifier may be applied only to local reference variables. That includes local variables declared with the ref modifier and parameters declared with the in, ref or out modifiers. The scoped modifier is implicitly added to this in methods declared in a struct, out parameters, and ref parameters when the type is a ref struct.")
    ("select" . "In a query expression, the select clause specifies the type of values that will be produced when the query is executed. The result is based on the evaluation of all the previous clauses and on any expressions in the select clause itself. A query expression must terminate with either a select clause or a group clause.")
    ("set" . "The set keyword defines an accessor method in a property or indexer that assigns a value to the property or the indexer element. For more information and examples, see Properties, Auto-Implemented Properties, and Indexers.")
    ("unmanaged" . "You can specify the calling convention for a delegate* using the keywords managed and unmanaged. In addition, for unmanaged function pointers, you can specify the calling convention. The following declarations show examples of each. The first declaration uses the managed calling convention, which is the default. The next four use an unmanaged calling convention. Each specifies one of the ECMA 335 calling conventions: Cdecl, Stdcall, Fastcall, or Thiscall. The last declaration uses the unmanaged calling convention, instructing the CLR to pick the default calling convention for the platform. The CLR will choose the calling convention at run time.")
    ("value" . "The contextual keyword value is used in the set accessor in property and indexer declarations. It is similar to an input parameter of a method. The word value references the value that client code is attempting to assign to the property or indexer.")
    ("var" . "When you declare a local variable, you can let the compiler infer the type of the variable from the initialization expression. To do that use the var keyword instead of the name of a type.")
    ("when" . "You use the when contextual keyword to specify a filter condition in the following contexts: 1. In a catch clause of a try-catch or try-catch-finally statement. 2. As a case guard in the switch statement. 3. As a case guard in the switch expression.")
    ("where" . "The where clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function. Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type. They declare capabilities that the type argument must have, and must be placed after any declared base class or implemented interfaces.")
    ("with" . "Available in C# 9.0 and later, a with expression produces a copy of its operand with the specified properties and fields modified. You use the object initializer syntax to specify what members to modify and their new values:")
    ("yield" . "You use the yield statement in an iterator to provide the next value or signal the end of an iteration. The yield statement has the two following forms: 1. yield return: to provide the next value in iteration. 2. yield break: to explicitly signal the end of iteration. Iteration also finishes when control reaches the end of an iterator.")))

(defun auto-complete-csharp--get-csharp-keywords()
  "Returns list containing C# keywords and their documentation."
  (mapcar #'car auto-complete-csharp--keywords))

(defun auto-complete-csharp--get-documentation (csharp-symbol)
  "Return a string containing the documention of CSHARP-SYMBOL.
CSHARP-SYMBOL is a string naming the C# keyword from `auto-complete-csharp--keywords'
Returns `nil' if CSHARP-SYMBOL doesn't exist in `auto-complete-csharp--keywords'."
  (let ((csharp-symbol-string (substring-no-properties csharp-symbol)))
    (cdr (assoc csharp-symbol-string auto-complete-csharp--keywords))))

(defvar ac-source-csharp
  '((candidates . auto-complete-csharp--get-csharp-keywords)
    (document . auto-complete-csharp--get-documentation)
    (cache))
  "auto-complete.el source for csharp keywords.")

(provide 'auto-complete-csharp)
;;; auto-complete-csharp.el ends here
